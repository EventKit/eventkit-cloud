# Thread fixes

## Dependencies

### Critical

- lodash
  - Multiple versions across different dependencies
    - lodash._baseassign:3.2.0
    - lodash._baseclone:3.3.0
    - lodash._getnative:3.9.1
    - lodash._isiterateecall:3.0.9
    - lodash.debounce:4.0.8
    - lodash.defaultsdeep:4.6.1
    - lodash.escape:4.0.1
    - lodash.flattendeep:4.4.0
    - lodash.get:4.4.2
    - lodash.isarguments:3.1.0
    - lodash.merge:4.6.2
  - Versions of lodash lower than 4.17.12 are vulnerable to Prototype Pollution
- webpack-merge:5.8.0
  - All versions of package @ianwalter/merge are vulnerable to Prototype Pollution via the main (merge) function. Maintainer suggests using @generates/merger instead.
- merge-stream:2.0.0
  - Same as previous
  - All versions of package merge are vulnerable to Prototype Pollution via _recursiveMerge
- set-immediate-shim:1.0.1
  - This affects the package @strikeentco/set before 1.0.2
- babel-plugin-dynamic-import-node:2.3.3
  - This affects all versions of package node-import. The "params" argument of module function can be controlled by users without any sanitization.b. This is then provided to the “eval” function located in line 79 in the index file "index.js"
- eslint-import-resolver-node:0.3.6
  - same as previous
- get-caller-file:2.0.5
  - cdf_read_property_info in cdf.c in file through 5.37 does not restrict the number of CDF_VECTOR elements, which allows a heap-based buffer overflow (4-byte out-of-bounds write).
- write-file-atomic:4.0.1
  - same as previous
- parseurl:1.3.3
  - Server-Side Request Forgery (SSRF) in GitHub repository ionicabizau/parse-url prior to 7.0.0.
- faye-websocket:0.11.4
  - Faye (NPM, RubyGem) versions greater than 0.5.0 and before 1.0.4, 1.1.3 and 1.2.5, has the potential for authentication bypass in the extension system. The vulnerability allows any client to bypass checks put in place by server-side extensions, by appending extra segments to the message channel. It is patched in versions 1.0.4, 1.1.3 and 1.2.5.

### High

- lodash
  - Multiple versions across different dependencies
    - lodash._baseassign:3.2.0
      - Lodash versions prior to 4.17.21 are vulnerable to Command Injection via the template function.
    - lodash._baseclone:3.3.0
    - lodash._getnative:3.9.1
    - lodash._isiterateecall:3.0.9
    - lodash.debounce:4.0.8
    - lodash.defaultsdeep:4.6.1
    - lodash.escape:4.0.1
    - lodash.flattendeep:4.4.0
    - lodash.get:4.4.2
    - lodash.isarguments:3.1.0
    - lodash.isequalwith:4.4.0
    - lodash.isarray:3.0.4
      - Prototype pollution attack when using _.zipObjectDeep in lodash before 4.17.20.
      - Following have the same message:
        - lodash.isempty:4.4.0
        - lodash.isequal:4.5.0
        - lodash.keys:3.1.2
        - lodash.memoize:4.1.2
        - lodash.merge:4.6.2
        - lodash.isequalwith:4.4.0
- neo-async:2.6.2
  - In Async before 2.6.4 and 3.x before 3.2.2, a malicious user can obtain privileges via the mapValues() method, aka lib/internal/iterator.js createObjectIterator prototype pollution.
- run-async:2.4.1
  - same as previous
- content-type:1.0.4
  - The content module is a module to parse HTTP Content-* headers. It is used by the hapijs framework to provide this functionality. The module is vulnerable to regular expression denial of service when passed a specifically crafted Content-Type or Content-Disposition header.
- to-no-case:1.0.2
  - The no-case module is vulnerable to regular expression denial of service. When malicious untrusted user input is passed into no-case it can block the event loop causing a denial of service condition.
- escape-string-regexp:2.0.0
  - The string module is a module that provides extra string operations. The string module is vulnerable to regular expression denial of service when specifically crafted untrusted user input is passed into the underscore or unescapeHTML methods.
- string_decoder:1.3.0
  - same as previous
- is-string:1.0.7
  - same as previous
- require-from-string:2.0.2
  - same as previous
- lz-string:1.4.4
  - same as previous
- string.prototype.trim:1.2.6
  - same as previous
  - All versions of package trim are vulnerable to Regular Expression Denial of Service (ReDoS) via trim().
- @types/mime:1.3.2
  - The mime module < 1.4.1, 2.0.1, 2.0.2 is vulnerable to regular expression denial of service when a mime lookup is performed on untrusted user input.
- content-disposition:0.5.4
  - The content module is a module to parse HTTP Content-* headers. It is used by the hapijs framework to provide this functionality. The module is vulnerable to regular expression denial of service when passed a specifically crafted Content-Type or Content-Disposition header.
- websocket-extensions:0.1.4
  - websocket-extensions ruby module prior to 0.1.5 allows Denial of Service (DoS) via Regex Backtracking. The extension parser may take quadratic time when parsing a header containing an unclosed string parameter value whose content is a repeating two-byte sequence of a backslash and some other character. This could be abused by an attacker to conduct Regex Denial Of Service (ReDoS) on a single-threaded server by providing a malicious payload with the Sec-WebSocket-Extensions header.
- is-unicode-supported:0.1.0
  - unicode loads unicode data downloaded from unicode.org into nodejs. Unicode before 9.0.0 downloads binary resources over HTTP, which leaves it vulnerable to MITM attacks.
  - **DISPUTED** An issue was discovered in the character definitions of the Unicode Specification through 14.0. The specification allows an adversary to produce source code identifiers such as function names using homoglyphs that render visually identical to a target identifier. Adversaries can leverage this to inject code via adversarial identifier definitions in upstream software dependencies invoked deceptively in downstream software. NOTE: the Unicode Consortium offers the following alternative approach to presenting this concern. An issue is noted in the nature of international text that can affect applications that implement support for The Unicode Standard (all versions). Unless mitigated, an adversary could produce source code identifiers using homoglyph characters that render visually identical to but are distinct from a target identifier. In this way, an adversary could inject adversarial identifier definitions in upstream software that are not detected by human reviewers and are invoked deceptively in downstream software. The Unicode Consortium has documented this class of security vulnerability in its document, Unicode Technical Report #36, Unicode Security Considerations. The Unicode Consortium also provides guidance on mitigations for this class of issues in Unicode Technical Standard #39, Unicode Security Mechanisms.
  - **DISPUTED** An issue was discovered in the Bidirectional Algorithm in the Unicode Specification through 14.0. It permits the visual reordering of characters via control sequences, which can be used to craft source code that renders different logic than the logical ordering of tokens ingested by compilers and interpreters. Adversaries can leverage this to encode source code for compilers accepting Unicode such that targeted vulnerabilities are introduced invisibly to human reviewers. NOTE: the Unicode Consortium offers the following alternative approach to presenting this concern. An issue is noted in the nature of international text that can affect applications that implement support for The Unicode Standard and the Unicode Bidirectional Algorithm (all versions). Due to text display behavior when text includes left-to-right and right-to-left characters, the visual order of tokens may be different from their logical order. Additionally, control characters needed to fully support the requirements of bidirectional text can further obfuscate the logical order of tokens. Unless mitigated, an adversary could craft source code such that the ordering of tokens perceived by human reviewers does not match what will be processed by a compiler/interpreter/etc. The Unicode Consortium has documented this class of vulnerability in its document, Unicode Technical Report #36, Unicode Security Considerations. The Unicode Consortium also provides guidance on mitigations for this class of issues in Unicode Technical Standard #39, Unicode Security Mechanisms, and in Unicode Standard Annex #31, Unicode Identifier and Pattern Syntax. Also, the BIDI specification allows applications to tailor the implementation in ways that can mitigate misleading visual reordering in program text; see HL4 in Unicode Standard Annex #9, Unicode Bidirectional Algorithm.
- regenerate-unicode-properties:10.0.1
  - same as previous
- unicode-match-property-value-ecmascript:2.0.0
  - same as previous
  - unicode loads unicode data downloaded from unicode.org into nodejs. Unicode before 9.0.0 downloads binary resources over HTTP, which leaves it vulnerable to MITM attacks.
- @babel/plugin-proposal-unicode-property-regex:7.16.7
  - same as previous
- xml-name-validator:4.0.0
  - validator.js is vulnerable to Inefficient Regular Expression Complexity
- terser-webpack-plugin:5.3.6
  - The package terser before 4.8.1, from 5.0.0 and before 5.14.2 are vulnerable to Regular Expression Denial of Service (ReDoS) due to insecure usage of regular expressions.
- is-docker:2.2.1
  - runc through 1.0-rc6, as used in Docker before 18.09.2 and other products, allows attackers to overwrite the host runc binary (and consequently obtain host root access) by leveraging the ability to execute a command as root within one of these types of containers: (1) a new container with an attacker-controlled image, or (2) an existing container, to which the attacker previously had write access, that can be attached with docker exec. This occurs because of file-descriptor mishandling, related to /proc/self/exe.
  - In Docker before 18.09.4, an attacker who is capable of supplying or manipulating the build path for the "docker build" command would be able to gain command execution. An issue exists in the way "docker build" processes remote git URLs, and results in command injection into the underlying "git clone" command, leading to code execution in the context of the user executing the "docker build" command. This occurs because git ref can be misinterpreted as a flag.
  - Docker Desktop before 4.5.1 on Windows allows attackers to move arbitrary files. NOTE: this issue exists because of an incomplete fix for CVE-2022-23774
  - Docker Desktop Community before 2.5.0.0 on macOS mishandles certificate checking, leading to local privilege escalation.
  - In Docker CE and EE before 18.09.8 (as well as Docker EE before 17.06.2-ee-23 and 18.x before 18.03.1-ee-10), Docker Engine in debug mode may sometimes add secrets to the debug log. This applies to a scenario where docker stack deploy is run to redeploy a stack that includes (non external) secrets. It potentially applies to other API users of the stack API if they resend the secret.
  - runc through 1.0.0-rc8, as used in Docker through 19.03.2-ce and other products, allows AppArmor restriction bypass because libcontainer/rootfs_linux.go incorrectly checks mount targets, and thus a malicious Docker image can mount over a /proc directory.
- electron-to-chromium:1.4.137
  - GitHub Electron before 1.6.8 allows remote command execution because of a nodeIntegration bypass vulnerability. This also affects all applications that bundle Electron code equivalent to 1.6.8 or earlier. Bypassing the Same Origin Policy (SOP) is a precondition; however, recent Electron versions do not have strict SOP enforcement. Combining an SOP bypass with a privileged URL internally used by Electron, it was possible to execute native Node.js primitives in order to run OS commands on the user's host. Specifically, a chrome-devtools://devtools/bundled/inspector.html window could be used to eval a Node.js child_process.execFile API call.
  - Multiple unspecified vulnerabilities in Google Chrome before 40.0.2214.91 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
  - Multiple unspecified vulnerabilities in Google V8 before 3.30.33.15, as used in Google Chrome before 40.0.2214.91, allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
  - WebKit, as used in Apple Safari before 5.0.6, allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption and application crash) via a crafted web site, a different vulnerability than other WebKit CVEs listed in APPLE-SA-2011-07-20-1.
  - An issue was discovered in certain Apple products. iOS before 10.3.2 is affected. macOS before 10.12.5 is affected. The issue involves the "SQLite" component. It allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption and application crash) via a crafted web site.
- get-caller-file:2.0.5
  - readelf.c in file before 5.22, as used in the Fileinfo component in PHP before 5.4.37, 5.5.x before 5.5.21, and 5.6.x before 5.6.5, does not consider that pread calls sometimes read only a subset of the available data, which allows remote attackers to cause a denial of service (uninitialized memory access) or possibly have unspecified other impact via a crafted ELF file.
- write-file-atomic:4.0.1
  - same as previous
- package-lock.json
  - The merge.recursive function in the merge package <1.2.1 can be tricked into adding or modifying properties of the Object prototype. These properties will be present on all objects allowing for a denial of service attack.
- faye-websocket:0.11.4
  - Faye before version 1.4.0, there is a lack of certification validation in TLS handshakes. Faye uses em-http-request and faye-websocket in the Ruby version of its client. Those libraries both use the `EM::Connection#start_tls` method in EventMachine to implement the TLS handshake whenever a `wss:` URL is used for the connection. This method does not implement certificate verification by default, meaning that it does not check that the server presents a valid and trusted TLS certificate for the expected hostname. That means that any `https:` or `wss:` connection made using these libraries is vulnerable to a man-in-the-middle attack, since it does not confirm the identity of the server it is connected to. The first request a Faye client makes is always sent via normal HTTP, but later messages may be sent via WebSocket. Therefore it is vulnerable to the same problem that these underlying libraries are, and we needed both libraries to support TLS verification before Faye could claim to do the same. Your client would still be insecure if its initial HTTPS request was verified, but later WebSocket connections were not. This is fixed in Faye v1.4.0, which enables verification by default. For further background information on this issue, please see the referenced GitHub Advisory.
- opener:1.5.2
  - A specifically crafted packet sent by an attacker to EIPStackGroup OpENer EtherNet/IP commits and versions prior to Feb 10, 2021 may result in a denial-of-service condition.
  - A specifically crafted packet sent by an attacker to EIPStackGroup OpENer EtherNet/IP commits and versions prior to Feb 10, 2021 may allow the attacker to read arbitrary data.
- parseurl:1.3.3
  - Exposure of Sensitive Information to an Unauthorized Actor in GitHub repository ionicabizau/parse-url prior to 7.0.0.
- path-parse:1.0.7
  - Authorization Bypass Through User-Controlled Key in GitHub repository ionicabizau/parse-path prior to 5.0.0.

---

## Code files

### Criticals

- Exposure of Sensitive Information to an Unauthorized Actor
  - Insecure Transport: Mail Transmission
    - `settings/prod.py line 4`
      - `import json`
    - `settings/prod.py line 120`
      - `EMAIL_HOST = os.getenv("EMAIL_HOST", None)`

### Highs

- Cookie Security: Overly Broad Path
  - Recommendations: Make sure to set cookie paths to be as restrictive as possible. Example 2: The following code shows how to set the cookie path to "/MyForum" for the example in the Explanation section.
  - `eventkit/eventkit-cloud/dev/deploy_eventkit_1_5_3/eventkit-cloud/eventkit_cloud/settings/prod.py line 279`
    - `SESSION_COOKIE_PATH = '/'`
  - `eventkit/eventkit-cloud/dev/deploy_eventkit_1_5_3/eventkit-cloud/eventkit_cloud/settings/prod.py line 279`
    - `SESSION_COOKIE_PATH = '/'`
- Similar error as previous for different file
  - `settings.py line 53`
    - `SESSION_COOKIE_PATH = "/"`
  - `settings.py line 53`
    - `SESSION_COOKIE_PATH = "/"`
- Hard coded password
  - `bundler/tests/test_eventkit.py line 56`
    - `example_password = "test_password"`
  - `bundler/tests/test_eventkit.py line 56`
    - `example_password = "test_password"`
- Similar as previous, different files
  - `utils/tarzip/tests/test_client.py line 13`
    - `self.pkcs12_password = "secret_clear_text"`
  - `utils/tarzip/tests/test_client.py line 8`
    - `class TestTarZip(unittest.TestCase):`
- Path Manipulation
  - Recommendations: The best way to prevent path manipulation is with a level of indirection: create a list of legitimate values from which the user must select. With this approach, the user-provided input is never used directly to specify the resource name. In some situations this approach is impractical because the set of legitimate resource names is too large or too hard to maintain. Programmers often resort to implementing a deny list in these situations. A deny list is used to selectively reject or escape potentially dangerous characters before using the input. However, any such list of unsafe characters is likely to be incomplete and will almost certainly become out of date. A better approach is to create a list of characters that are permitted to appear in the resource name and accept input composed exclusively of characters in the approved set. Tips: 1.If the program performs custom input validation to your satisfaction, use Fortify Custom Rules Editor to create a cleanse rule for the validation routine. 2.Implementation of an effective deny list is notoriously difficult. One should be skeptical if validation logic requires implementing a deny list. Consider different types of input encoding and different sets of metacharacters that might have special meaning when interpreted by different operating systems, databases, or other resources. Determine whether or not the deny list can be updated easily, correctly, and completely if these requirements ever change.
  - Files:
    - `utils/auth_requests.py line 61`
      - `cert_pass = os.getenv(cert_pass_var)`
    - `utils/auth_requests.py line 61`
      - `cert_pass = os.getenv(cert_pass_var)`
    - `utils/auth_requests.py line 68`
      - `return cert_path, cert_pass`
    - `utils/auth_requests.py line 68`
      - `return cert_path, cert_pass`
    - `utils/auth_requests.py line 140`
      - `cert_path, cert_pass = get_cert_info(dict(cert_info=cert_info))`
    - `utils/auth_requests.py line 140`
      - `cert_path, cert_pass = get_cert_info(dict(cert_info=cert_info))`
    - `utils/auth_requests.py line 143`
      - `with open(cert_path, "rb") as pkcs12_file:`
